
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package humantracking.analyze.gui;

import com.googlecode.javacv.FrameGrabber;
import com.googlecode.javacv.cpp.opencv_core;
import static com.googlecode.javacv.cpp.opencv_core.cvClearMemStorage;
import com.googlecode.javacv.cpp.opencv_highgui;
import static com.googlecode.javacv.cpp.opencv_highgui.CV_FOURCC;
import com.googlecode.javacv.cpp.opencv_highgui.CvVideoWriter;
import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.awt.image.WritableRaster;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import org.opencv.core.Core;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.core.MatOfDouble;
import org.opencv.core.MatOfFloat;
import org.opencv.core.MatOfInt;
import org.opencv.core.MatOfPoint;
import org.opencv.core.MatOfRect;
import org.opencv.core.Point;
import org.opencv.core.Rect;
import org.opencv.core.Scalar;
import org.opencv.core.Size;
import org.opencv.highgui.VideoCapture;
import org.opencv.imgproc.Imgproc;
import org.opencv.objdetect.CascadeClassifier;
import org.opencv.objdetect.HOGDescriptor;
import org.opencv.video.BackgroundSubtractorMOG;
import org.opencv.video.BackgroundSubtractorMOG2;

/**
 *
 * @author Darshana Priyasad
 */
public class VideoAnalyzer extends javax.swing.JFrame {

    private String filePath;
    CascadeClassifier classifier;
    private opencv_core.CvMemStorage storage;

    /**
     * Creates new form VideoAnalyzer
     */
    public VideoAnalyzer() {
        initComponents();
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
        setTitle("Video Analizer");
        classifier = new CascadeClassifier();
        setIconImage(new ImageIcon("./src/humantracking/images/camera.png").getImage());
        classifier.load("./src/humantracking/support/haarcascade_fullbody.xml");
        //classifier = new opencv_objdetect.CvHaarClassifierCascade(cvLoad("C:\\Users\\Darshana Priyasad\\Documents\\NetBeansProjects\\HumanTracking\\src\\humantracking\\support\\hogcascade_pedestrians.xml"));
        storage = opencv_core.CvMemStorage.create();
        setSize(Toolkit.getDefaultToolkit().getScreenSize());
        setLocationRelativeTo(null);
        setVisible(true);
        //analyzeForMultiple();
        this.toFront();

        analyze();
        /*try {
         test();
         } catch (IOException ex) {
         Logger.getLogger(VideoAnalyzer.class.getName()).log(Level.SEVERE, null, ex);
         }*/
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jPanel2 = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        jPanel4 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jPanel5 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBackground(new java.awt.Color(255, 255, 255));

        jPanel2.setBackground(new java.awt.Color(255, 255, 255));
        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Processed Video", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 1, 14), new java.awt.Color(255, 0, 0))); // NOI18N

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, 635, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, 484, Short.MAX_VALUE)
                .addContainerGap())
        );

        jPanel4.setBackground(new java.awt.Color(255, 255, 255));
        jPanel4.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Processing Video", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 1, 14), new java.awt.Color(255, 0, 0))); // NOI18N

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, 641, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jPanel5.setBackground(new java.awt.Color(255, 255, 255));

        jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/humantracking/images/analizeWIndow.png"))); // NOI18N

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, 100, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(6, 6, 6)
                .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(jPanel5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(45, 45, 45)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(VideoAnalyzer.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(VideoAnalyzer.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(VideoAnalyzer.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(VideoAnalyzer.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new VideoAnalyzer().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    // End of variables declaration//GEN-END:variables

    /*
     public void show() {

     System.loadLibrary(Core.NATIVE_LIBRARY_NAME);

     opencv_highgui.CvCapture capture = opencv_highgui.cvCreateFileCapture("C:/Users/Darshana Priyasad/Documents/NetBeansProjects/HumanTracking/src/humantracking/video/play.avi");

     new Thread() {

     @Override
     public void run() {

     opencv_core.IplImage frame;

     BufferedImage image;

     while (true) {
     frame = opencv_highgui.cvQueryFrame(capture);
     if (frame == null) {

     break;
     }
     System.out.println("name");
     image = frame.getBufferedImage();
     ImageIcon icon = new ImageIcon(image);

     int count = 0 ;
     try {
     File outputfile = new File("new"+count+++".png");
     ImageIO.write(image, "png", outputfile);
     } catch (Exception e) {
     System.out.println("error");
     }
     //label = new JLabel(icon);
     //photo is the name of the JPanel
     jLabel1.setIcon(icon);
     jLabel1.repaint();
     jLabel1.revalidate();
     //System.out.println("done");

     }

     opencv_highgui.cvReleaseCapture(capture);

     }

     }.start();
     }
     */
    /*
     public void view() {

     new Thread() {

     @Override
     public void run() {

     BufferedImage img1;

     OpenCVFrameGrabber grabber = new OpenCVFrameGrabber(0);

     try {
     boolean name = true;
     grabber.start();
     while (true) {
     name = false;
     IplImage img = grabber.grab();
     if (img != null) {
     img1 = img.getBufferedImage();
     ImageIcon icon = new ImageIcon(img1);
     //label = new JLabel(icon);
     //photo is the name of the JPanel
     jLabel1.setIcon(icon);
     jLabel1.repaint();
     jLabel1.revalidate();
     System.out.println("done");
     }
     }
     //grabber.stop();
     } catch (FrameGrabber.Exception ex) {
     Logger.getLogger(VideoAnalyzer.class.getName()).log(Level.SEVERE, null, ex);

     }

     }

     }.start();
     }

     */
    public void setFilePath(String filePath) {
        this.filePath = filePath;
        analyze();
    }

    private void analyze() {
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
        final BackgroundSubtractorMOG2 backgroundSubtractorMOG = new BackgroundSubtractorMOG2(10, 16, false);
        final Mat frame = new Mat();
        final VideoCapture capture = new VideoCapture(0);

        
        new Thread() {

            @Override
            public void run() {

                //opencv_highgui.CvCapture capture = opencv_highgui.cvCreateFileCapture(filePath);
                //VideoCapture capture1 = new VideoCapture(0);
                // FrameGrabber grabber = FrameGrabber.createDefault(0);
                Vector files = new Vector();
                int count = 0 ;

                while (true) {

                    if (capture.read(frame)) {

                        BufferedImage orgImage = createAwtImage(frame);
                        orgImage = resize(orgImage, 640, 480);
                        byte[] data = ((DataBufferByte) orgImage.getRaster().getDataBuffer()).getData();
                        Mat camImage = new Mat(orgImage.getHeight(), orgImage.getWidth(), CvType.CV_8UC3);

                        camImage.put(0, 0, data);

                        Imgproc.cvtColor(camImage, camImage, Imgproc.COLOR_RGB2GRAY);
                        Imgproc.GaussianBlur(camImage, camImage, new Size(3.0, 3.0), 10);
                        //Imgproc.blur(camImage, camImage, new Size(3.0, 3.0));

                        Mat fgMask = new Mat();
                        backgroundSubtractorMOG.apply(camImage, fgMask, 0.1);

                        boolean findContours = findContours(fgMask);
                        
                        BufferedImage result = createAwtImage(fgMask);

                        if (findContours) {
                            count++;
                            String fileName = "./src/images/"+count+".jpg";
                            File outputfile = new File(fileName);
                            try {
                                ImageIO.write(orgImage, "jpg", outputfile);
                            } catch (IOException ex) {
                                Logger.getLogger(VideoAnalyzer.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            files.add(fileName);
                        }else{
                            if(!files.isEmpty()){
                                JpegImagesToMovie jpegImagesToMovie = new JpegImagesToMovie();
                                jpegImagesToMovie.convert(files);
                            }
                            count = 0;
                            files.clear();
                        }
                        
                        
                        
                        
                        ImageIcon icon = new ImageIcon(result);
                        ImageIcon icon1 = new ImageIcon(orgImage);

                        jLabel1.setIcon(icon1);
                        jLabel1.repaint();
                        jLabel1.revalidate();
                        jPanel1.repaint();
                        jLabel1.revalidate();

                        jLabel3.setIcon(icon);

                        jLabel3.repaint();
                        jLabel3.revalidate();
                        jPanel2.repaint();
                        jLabel3.revalidate();

                    }
                }

            }
        }.start();
    }

    public boolean findContours(Mat imageA) {

        boolean found = false;

        List<MatOfPoint> contours = new ArrayList<MatOfPoint>();
        Imgproc.findContours(imageA, contours, new Mat(), Imgproc.RETR_LIST, Imgproc.CHAIN_APPROX_SIMPLE);
        //Imgproc.drawContours(imageBlurr, contours, 1, new Scalar(0,0,255));
        for (int i = 0; i < contours.size(); i++) {
            System.out.println(Imgproc.contourArea(contours.get(i)));
            if (Imgproc.contourArea(contours.get(i)) > 50) {
                Rect rect = Imgproc.boundingRect(contours.get(i));
                //System.out.println(rect.height);
                if (rect.height > 28) {
                    //System.out.println(rect.x +","+rect.y+","+rect.height+","+rect.width);
                    found = true;
                    Core.rectangle(imageA, new Point(rect.x, rect.y), new Point(rect.x + rect.width, rect.y + rect.height), new Scalar(255, 0, 0));
                }
            }
        }
        return found;

    }

    private BufferedImage process(BufferedImage old, int number) {
        int w = old.getWidth();
        int h = old.getHeight();
        BufferedImage img = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = img.createGraphics();
        g2d.drawImage(old, 0, 0, null);
        g2d.setPaint(Color.red);
        g2d.setFont(new Font("Serif", Font.BOLD, 48));
        String s = "";
        if (number > 0) {
            s = number + " Humans Detected";

        } else {
            s = "Non - Human Object Detected";
        }

        FontMetrics fm = g2d.getFontMetrics();
        int x = img.getWidth() - fm.stringWidth(s) - 5;
        int y = fm.getHeight();
        g2d.drawString(s, x, y);
        g2d.dispose();

        return img;
    }

    public static BufferedImage resize(BufferedImage img, int newW, int newH) {
        Image tmp = img.getScaledInstance(newW, newH, Image.SCALE_SMOOTH);
        BufferedImage dimg = new BufferedImage(newW, newH, BufferedImage.TYPE_3BYTE_BGR);

        Graphics2D g2d = dimg.createGraphics();
        g2d.drawImage(tmp, 0, 0, null);
        g2d.dispose();

        return dimg;
    }

    public static BufferedImage createAwtImage(Mat mat) {

        int type = 0;
        if (mat.channels() == 1) {
            type = BufferedImage.TYPE_BYTE_GRAY;
        } else if (mat.channels() == 3) {
            type = BufferedImage.TYPE_3BYTE_BGR;
        } else {
            return null;
        }

        BufferedImage image = new BufferedImage(mat.width(), mat.height(), type);
        WritableRaster raster = image.getRaster();
        DataBufferByte dataBuffer = (DataBufferByte) raster.getDataBuffer();
        byte[] data = dataBuffer.getData();
        mat.get(0, 0, data);

        return image;
    }

    public int HogDetector(Mat mat) {

        final HOGDescriptor hog = new HOGDescriptor();
        final MatOfFloat descriptors = HOGDescriptor.getDefaultPeopleDetector();

        hog.setSVMDetector(descriptors);

        final MatOfRect foundLocations = new MatOfRect();
        final MatOfDouble foundWeights = new MatOfDouble();
        final Size winStride = new Size(8, 8);
        final Size padding = new Size(32, 32);
        //System.out.println("dsdsdd");
        if (mat != null) {
            // CHECKSTYLE:OFF MagicNumber - Magic numbers here for illustration
            hog.detectMultiScale(mat, foundLocations, foundWeights, 0.0, winStride, padding, 1.05, 2.0, false);
            // CHECKSTYLE:ON MagicNumber
            double[] toArray = foundWeights.toArray();
            int good_humans = 0;
            double[] weights_array = foundWeights.toArray();
            for (int i = 0; i < weights_array.length; i++) {
                if (weights_array[i] < 0.5) {
                    good_humans++;
                }
            }
            //System.out.println(Arrays.toString(toArray));
            return good_humans;
        }
        return 0;

    }

    public void loadClassifier(Mat img) {

        MatOfRect rectList = new MatOfRect();
        MatOfDouble matDouble = new MatOfDouble(1.2);
        MatOfInt matOfInt = new MatOfInt(3);
        classifier.detectMultiScale(img, rectList, matOfInt, matDouble);

        //cascade.detectMultiScale(gray, faces, 1.2, 3);
        System.out.println(rectList.size().toString());
        cvClearMemStorage(storage);
    }

}
